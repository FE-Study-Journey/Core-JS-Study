# 3장 this

### this

this바인딩은 실행컨텍스트가 `활성화 될 때 한다.`

컨텍스트에 해당하는 함수가 호출 될 때 `실행컨텍스트가 생성되고` 이때 `this바인딩`이 이루어진다.

this는 **`함수가 호출될 때 결정된다.`** 하지만 어떻게 호출되느냐에 따라 this는 달라진다.

### 호출에 따른 this 변화

- 전역공간에서
  - this는 전역객체를 가르킨다.(`브라우저 환경 window`, `node.js환경 global`)
  - 개념상 전역 컨텍스트를 실행하는 주체가 전역객체이기 때문이다.(host 객체라고도 부른다.)
  - 이 두 객체들은 ECMAScript에서 정의한 객체가 아니라 ECMAScript가 ‘전역객체는 이러이러해야한다’ 라는 내용에 따라서 런타임에서 제공하는 구현체이다.
  - 각 호스트 환경에서 정의한 것에 따라서 전역객체의 구체적인 내용이 달라진다.
- 함수 호출시
  - 함수 호출시에도 this는 전역객체를 가르킨다.
  - 전역공간에서 호출하는 함수는 전역객체를 가르킨다. 하지만 함수 내부에서 호출하는 함수도 전역객체를 가르킨다.
  - 이것은 일종의 버그다 하는 얘기도 있다. ES6환경에서는 arrow function이 나옴(바로 위 컨텍스트에 있는 this를 그대로 가져와 사용함)
  - ES5환경에서 `함수로 호출된 this는 언제나 전역객체를 가르킨다.`
- 메서드 호출시
  - 메서드 호출 주체에 바인딩 된다.
  - 아래 예시 코드에서 this는 a가 된다. (.앞에 있는 객체에 바인딩 된다.)
    ```jsx
    let a = {
      b: function () {
        console.log(this);
      },
    };
    a.b();
    ```
  - 위 코드에서 b는 원래 함수이지만 자바스크립트에서는 `어떤 객체와 ‘관련된 동작을 하게 되면’ 메서드라고 부르겠다` 라는 것이다.
  - 아래 예시 코드에서 this는 a.b이다. (에디터에 따라 색상으로도 표시가 됨) 예시 코드 둘 다 메서드인 b, c만 빨간색이다!
    ```jsx
    let a = {
      b: {
        c: function () {
          console.log(this);
        },
      },
    };
    a.b.c();
    ```
  - 메서드 내부함수에서의 우회법
  ```jsx
  let a = 10;
  let obj = {
    a: 20,
    b: function () {
      console.log(this.a);
      function c() {
        console.log(this.a);
      }
      c();
    },
  };
  obj.b();
  ```
  - 위 코드의 출력값은 20과 undefined이다.
  - 이유는 다음과 같다.
  - obj.b가 호출되면서 b에서의 this는 obj 객체에 바인딩된다. obj객체 안에는 a가 있고 값이 20이기 때문에 20이 출력된다.
  - c는 obj.b처럼 메서드로서의 호출이 아니라 그냥 함수 호출이다. 위에 설명에서 함수 호출에 경우 무조건 전역객체를 가르킨다고 설명했다. 그렇기 때문에 undefined가 출력된다.
  - 우회법
  ```jsx
  let a = 10;
  let obj = {
    a: 20,
    b: function () {
      let _this = this;
      console.log(this.a);
      function c() {
        console.log(_this.a);
      }
      c();
    },
  };
  obj.b();
  ```
  - 2장 실행컨텍스트를 공부했던 부분이 이렇게도 사용되었다.
  - b메서드에 \_this라는 변수에 this를 할당했다.(여기서 this는 obj객체이다.)
  - c함수에서 \_this.a를 출력하고자한다. c함수에 environmentRecord에는 \_this라는 식별자가 없다. outerEnvironmentReference를 통해 b메서드의 environmentRecord에서 \_this라는 식별자를 찾는다.
  - 식별자가 존재하므로 b메서드의 environmentRecord에서 \_this의 정보를 가져온다.
  - 여기서 \_this변수에는 obj를 가르키는 this가 들어있다. 그렇기 때문에 \_this.a는 obj객체 안에 a를 참조한다.
  - b메서드 안에서 this.a와 c함수 안에서 \_this.a는 둘 다 같은 obj객체 안에 있는 a를 참조한다.
  - 실행결과는 20 20이 출력된다.
- callback 호출시
  - 기본적으로는 함수내부에서와 동일
  -
  ```jsx
  let callback = function () {
    console.log(this);
  };

  let obj = {
    a: 1,
    b: function (cb) {
      cb();
    },
  };
  obj.b(callback);
  ```
  - 여기서 cb를 호출했을 때 함수를 호출한 것이기 때문에 전역객체가 출력된다.
  -
  ```jsx
  let callback = function () {
    console.log(this);
  };

  let obj = {
    a: 1,
    b: function (cb) {
      cb.call(this);
    },
  };
  obj.b(callback);
  ```
  - 여기서 cb를 호출했을 경우 call메서드를 통해 this를 바인딩 했기때문에 obj가 넘어가게 되므로 obj객체를 가르킨다.
- 콜백함수의 경우 콜백함수를 넘겨받는 대상이 `매개변수로 넘겨받은 함수를 어떻게 호출하느냐에 따라 this가 가르키는게 달라진다.`
  - 기본적으로는 콜백함수의 this는 함수의 this와 같다.(전역객체를 가르킴)
  - 제어권을 가진 함수가 콜백의 this를 지정해둔 경우도 있다.
  - 개발자가 this를 바인딩해서 콜백을 넘기면 그에 따라 this가 가르키는 것이 바뀐다.
- 생성자함수 호출시

### ES6 arrow function

```jsx
let a = 10;

let obj = {
  a: 20,
  b: function () {
    console.log(this.a);

    const c = () => {
      console.log(this.a);
    };
    c();
  },
};
obj.b();
```

화살표 함수의 this는 함수가 정의될 때의 `상위 컨텍스트의 this를 그대로 사용한다.`

화살표 함수 자체는 `this를 바인딩하지 않고, 외부 함수나 코드의 this를 그대로 사용한다.`

여기서 c함수는 상위 컨텍스트의 this를 그대로 사용하기 때문에 this는 obj객체를 가르킨다.

### ES5 call, apply, bind 메서드

```jsx
function a(x, y, z) {
  console.log(this, x, y, z);
}

let b = {
  bb: "bbb",
};

a.call(b, 1, 2, 3);

a.apply(b, [1, 2, 3]);

let c = a.bind(b);
c(1, 2, 3);

let d = a.bind(b, 1, 2);
d(3);
```

- call 메서드에서 a.call(b, 1, 2, 3) 이 부분은 this를 b에 바인딩하고 매개변수로 1, 2, 3을 넘겨준 것이다.
- apply 메서드에서는 a.apply(b, [1, 2, 3]) 이 부분은 this를 b에 바인딩하고 매개변수로 [1, 2 ,3] 배열을 넘겨준 것이다.
- c변수는 a의 this부분에 b를 바인딩하고 c를 호출할 때 (1, 2, 3)이라는 매개변수를 넘겨준 것이다.
- d변수는 a의 this부분에 b를 바인딩하고 1, 2를 매개변수로 넘겨주고 d를 호출할 때 3을 매개변수로 넘겨준 것이다.
- 위 코드들의 실행결과는 { bb: 'bbb' } 1 2 3 이런 형식으로 출력되며 모두 같은 출력값이 출력된다.
- 위 메서드들은 `명시적으로 this를 바인딩 할 때 사용된다.`
