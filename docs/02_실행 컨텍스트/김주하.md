# 2장 실행 컨텍스트

## 실행 컨텍스트

- 실행 컨텍스트: **실행할 코드에 제공할 환경 정보들을 모아놓은 객체**
- JS: 동적 언어 성격 두드러짐
- **호이스팅**, this 값 설정 등에서 볼 수 있음

### 스택 vs 큐

- 스택(STACK): LIFO (선입선출) -> ★스택 오버플로우(ERROR)
- 큐(QUEUE): FIFO(선입선출)

### 콜 스택

- 동일한 환경 = 하나의 실행 컨텍스트 구성 방법
  - "함수 실행"
- 동일 코드를 실행할 때 필요한 환경정보들을 모아 컨텍스트 구성 -> 콜 스택 누적 -> 가장 위에 있는 컨텍스트와 관련있는 코드 실행
- 전체 코드의 환경과 순서 보장
  - 전역 공간: 자동 생성
  - eval(): 보안 상 이유로 사용 지양
  - **함수**: 실행 컨텍스트를 생성하는 일반적인 방법

cf)

- 식별자: 매개변수 이름, 함수, 변수명
- 식별자 선언: 콜스택 상 실행 컨택스트가 활성화 된 상태

```
★실행 컨텍스트 활성화: 관련 코드를 실행하는데 필요한 환경 정보들을 수집해 실행 컨텍스트에 저장
```

```javascript
// call stack

// (1)코드를 실행하는 순간: 콜 스택에 전역 컨텍스트가 담김
var a = 1;
function outer() {
  function inner() {
    console.log(a); //undifined: strick mode
    var a = 3; //inner 함수 실행 종료: 콜 스택 제거 -> (2)번 줄로 이동
  }
  inner(); // (2)inner 함수 콜 스택 최상단: outer 컨텍스트 실행 중단 -> innner 함수 내부 코드 진행
  console.log(a); //outer 함수 실행 종료: (3)번 다음 줄로 이동
}
outer(); // (3)outer 에 대한 환경 정보 수집 -> outer 실행 컨텍스트 생성: 콜 스택에 담김
// ★ 전역 컨텍스트와 관련된 코드 실행 일시 중단 -> outer 함수 내부 순차 실행(outer 최상단 위치)
console.log(a); // 전역 컨텍스트 제거: 콜 스택 clear
```

- 최 상단: 브라우저에서 자동 실행 => js파일이 열리는 순간 전역 컨텍스트 활성화
  - 전역 공간: window(node: global/strict mode: undefined)

```
매개변수의 이름, 함수, 변수 명 등이 선언되면 js가 관련 코드를 실행하는데 필요한 환경 정보들을 수집해 실행 컨텍스트에 저장
```

## 환경정보

### Variable Environment(V.E)

- 현재 컨텍스트 내 식별자들에 대한 정보 + 외부 환경 정보, 선언 시점의 LevicalEnvironment의 스냅샷
- 변경사항 반영 x

### Lexical Environment(L.E)

- 초기 Variable Environment와 동일
- 변경사항 실시간 반영

### This Binding

- 식별자가 바라봐야 할 대상 객체
- this로 지정된 객체 저장
- 실행컨텍스트 활성화 당시에 this가 지정되지 않은 경우
  - 전역객체 저장

### V.E & L.E 내부(동일)

#### environment Record(eR)

- 현재 컨텍스트와 관련된 식별자 정보 저장
- 식별자의 값 X, **식별자**에 관심
- 컨텍스트 내부를 순서대로 숥으며 수집
- 코드 실행 전부터 해당 환경에 속한 식별자 정보를 모두 알고 있는 상태 = 호이스팅
  - 호이스팅: 식별자들을 최상단으로 끌어올림
  - 실행 컨텍스트가 활성화될 때 선언된 변수를 위로 끌어올림
  - 호이스팅 발생시 **변수명**만 끌어올려짐, 할당 과정은 그대로 유지
  - **var let const 차이점 발생** - var: LE 활성화시 eF에 의해 변수 선언부 호이스팅, undefined 초기화(참조 에러 x) - let, const: undefined를 할당하지 않은 채 변수 선언부만 호이스팅 - ReferenceError: Cannot access 'let변수' before initialization: 호이스팅이 되지만 **초기화가 이루어지지 않아** 에러 발생(참조 에러 o)
    cf)
- 함수 선언식 vs 함수 표현식
  - 함수 **선언**식: **함수 전체**를 끌어올림
    - 호이스팅이 끝난 상태에서 함수 선언문: 함수명으로 선언한 변수에 함수 할당
    - 전역 공간에서 함수 선언식 작성, 동명 함수 중복 선언 지양
  - 함수 **표현**식: 변수에 함수 할당: **변수**만 호이스팅
    - 변수부 undefined 할당, 선언부에서 선언
    - 선언 전 사용시 is not a function 에러 발생
    - 함수 표현식이 더 안전함

#### outer environment Reference(oeR)

- 호출된 함수가 **선언될 시점**의 L.E 참조를 가능하게 함
  - 스코프
    - 식별자에 대한 유효범위
    - ES6: const, let에 의해 생성되는 block 스코프 추가(+함수 스코프)
  - 스코프 체인
    - 식별자의 유효 범위를 안에서 밖으로 차례대로 검색
    - 전역 L.E에 닿을 때까지 찾지 못하면 undefined 반환
- 시점이 과거형인 이유: 선언 = 콜스택 상에서 어떤 실행 컨텍스트가 활성화 된 상태를 의미
- 선언 시점의 L.E를 계속 찾아 올라가다보면 그 끝은 전역 컨텍스트의 L.E
- oeR: **가장 가까운 요소부터 차례대로만 접근 가능**

  - **변수 은닉화**: 동일한 식별자가 선언됐을 경우에도 **무조건** 가장 먼저 발견된 식별자에게만 접근 가능

  ```javascript
  var a = 1; // 변수 은닉화: 접근 불가(전역변수)

  var outer = function () {
    var inner = function () {
      var a = 3; //inner 스코프 안에서 접근할 수 있는 유일한 변수 a(지역변수)
    };
    inner();
  };
  outer();
  ```
