# 5장 클로저

> 어떤 함수에서 선언한 변수를 참조하는 **내부함수**에서 발생하는 현상 - MDN

- 함수형 프로그래밍 언어에 등장하는 보편적인 특성
- 함수와 그 함수가 **선언될 당시의 LE**의 **상호관계**에 따른 현상
  - **선언될 당시의 LE?**: 실행 컨텍스트의 구성 요소 중 하나인 oER
  - **상호관계?**: 내부 함수에서 외부 변수를 참조하는 경우

```javascript
var outer = function () {
  var a = 1;
  var inner = function () {
    return ++a;
  };
  return inner;
};

var outer2 = outer(); //outer 종료
// outer2 -> inner 참조 (가비지 컬렉터 미수거: oER가 outer함수의 LE를 필요로 함)
console.log(outer2()); //2
console.log(outer2()); //3
```

- 외부 함수의 LE가 가비지 컬렉팅되지 않음

- 어떤 함수 outer에서 선언한 변수를 참조하는 내부함수 inner를 외부로 전달할 경우, outer의 실행 컨텍스트가 종료된 이후에도 변수가 사라지지 않아 접근 가능

## 클로저와 메모리 관리

> 참조 카운트를 0으로 만들면 메모리를 소모하지 않도록 할 수 있음

### 참조 카운트 0으로 만들기

- 식별자에 기본형 데이터 할당(참조형 x)
- null or undefined 할당

```javascript
// return에 의한 클로저 메모리 해제
var outer = (function () {
  var a = 1;
  var inner = function () {
    return ++a;
  };
  return inner;
})();

console.log(outer); // Function <- inner
outer = null;
console.log(outer); // null -> outer 식별자의 inner 함수 참조 끊기
```
