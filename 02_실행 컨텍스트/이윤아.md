# 2장 실행 컨텍스트

- [배경 지식](#배경-지식)
  - [스택과 큐의 개념](#스택과-큐의-개념)
  - [기타 용어 정리](#기타-용어-정리)
- [실행 컨텍스트란?](#실행-컨텍스트란)
  - [실행 컨텍스트가 쓰이는 곳](#실행-컨텍스트가-쓰이는-곳)
- [실행 컨텍스트의 구성 방법](#실행-컨텍스트의-구성-방법)
  - [실행 컨텍스트의 조건](#실행-컨텍스트의-조건)
    - [전역 공간](#전역-공간)
    - [함수](#함수)
    - [모듈 (module)](#모듈-module)
    - [eval](#eval)
  - [실행 컨텍스트의 구성](#실행-컨텍스트의-구성)
  - [실행컨텍스트의 추가와 삭제](#실행컨텍스트의-추가와-삭제)
  - [번외: 조건문과 반복문에서 실행 컨텍스트](#번외-조건문과-반복문에서-실행-컨텍스트)
  - [실행 컨텍스트의 내부: 실행 컨텍스트에 포함되는 환경정보](#실행-컨텍스트의-내부-실행-컨텍스트에-포함되는-환경정보)
- [호이스팅(Hoisting)과 LexicalEnvironment](#호이스팅hoisting과-lexicalenvironment)
  - [호이스팅(Hoisting)](#호이스팅hoisting)
  - [변수 호이스팅](#변수-호이스팅)
- [스코프 (Scope)와 스코프 체인 (Scope Chain)](#스코프-scope와-스코프-체인-scope-chain)
  - [스코프](#스코프)
  - [스코프 체인](#스코프-체인)

## 배경 지식
### 스택과 큐의 개념
- **공통점**: 데이터 컬렉션을 `저장`하고 `관리`하는 데 사용할 수 있는 데이터 구조
- **차이점**: 요소가 제거되는 `순서`가 다름
  - **스택**: 출입구가 하나뿐인 깊은 우물 같은 구조로, `선입후출(LIFO)` 방식
  - **큐**: 양쪽이 모두 열려있는 파이프 같은 구조로, `선입선출(FIFO)` 방식

<img width="448" src="https://github.com/user-attachments/assets/8540c636-06af-4606-ab6a-93e7d4f96ed9">

### 기타 용어 정리
- **호출 스택(call stack)**: 자바스크립트 코드가 실행되며 생성되는 실행 컨텍스트(Execution Context)를 저장하는 자료구조.
- **변수 은닉화**: 특정 변수의 접근을 제한하여 외부에서 직접 접근하거나 수정할 수 없도록 하는 프로그래밍 기법.

## 실행 컨텍스트란?
- **실행 컨텍스트**: 실행 코드에 제공할 조건, `환경 정보`를 담은 객체.

### 실행 컨텍스트가 쓰이는 곳
- **호이스팅**: 코드를 실행하기 전에 변수나 함수 선언을 코드의 맨 위로 옮겨서 해석하는 것처럼 동작.
- **this 값 설정**: 실행 컨텍스트가 활성화될 때, `this` 키워드가 참조할 객체를 결정하고 설정하는 과정.
- **스코프(scope)**: 변수와 함수가 서로 접근할 수 있는 유효 범위를 의미.
- **외부환경 정보 구성**: 실행 컨텍스트가 생성될 때, 현재 실행되는 코드의 외부 환경에 대한 정보를 수집하고 구성하는 과정.
- **클로저(closure)**: 주변 상태에 대한 참조와 함께 묶인 함수의 조합. 내부 함수에서 외부 함수의 범위에 대한 접근을 제공.

전역 컨텍스트: 자바스크립트 코드가 실행될 때 가장 먼저 생성되는 실행 컨텍스트. 자바스크립트 엔진이 코드를 실행하기 시작하면, 가장 먼저 전역 컨텍스트가 생성되고, 이후에 함수가 호출될 때마다 새로운 실행 컨텍스트가 생성됨.

## 실행 컨텍스트의 구성 방법
동일한 환경에 있는 코드들을 실행할 때 필요한 환경 정보를 모아 컨텍스트를 구성하고, 이를 호출 스택(call stack)에 쌓아 올렸다가, 가장 위에 쌓여 있는 컨텍스트와 관련 있는 코드들을 실행하는 방식으로 전체 코드의 환경과 순서를 보장함.

### 실행 컨텍스트의 조건
#### 전역 공간
- 전역 변수와 함수 선언이 포함된 실행 컨텍스트.
- 자바스크립트 코드가 실행되는 순간에 바로 생성되고, 전체 코드가 끝날 때 종료됨. **따라서 전역 공간은 거대한 함수 공간이라고 볼 수 있음.**

#### 함수
- 자바스크립트의 독립된 코드 뭉치.
- 함수가 호출될 때마다 새로운 실행 컨텍스트가 생성됨.
- 함수 실행이 종료될 때 호출 스택에서 제거됨.
- 자동으로 생성되는 모듈과 전역 공간, 특별한 경우가 아니면 사용되지 않는 `eval`을 제외하면 우리가 흔히 실행 컨텍스트를 구성하는 방법은 함수를 실행하는 것뿐임.

#### 모듈 (module)
- 모듈 시스템은 ES6부터 생긴 것으로, ES5 이하에서는 모듈 시스템이 존재하지 않음.
- 모듈 시스템(ES6)을 사용하는 경우, 각 모듈은 독립적인 실행 컨텍스트를 가짐.
- 모듈이 임포트되는 순간에 모듈 내부의 코드가 실행되면서 해당 모듈의 실행 컨텍스트가 생성되고, 모듈 코드가 전부 끝났을 때 컨텍스트가 종료됨. **따라서 모듈은 거대한 함수 공간이라고 볼 수 있음.**
- ES6 모듈 시스템에서는 import와 export 키워드를 사용하여 모듈을 정의하고 불러옴.
- 모듈의 기본 내보내기는 export default 키워드를 사용하며, 여러 개의 내보내기는 export 키워드를 사용함.
- 모듈을 불러올 때는 import 키워드를 사용하여 원하는 모듈을 선택적으로 불러올 수 있음.

### eval
- 여러 문제를 야기하는 위험한 명령어이기 때문에 특별한 경우가 아니면 사용되지 않음.
- 이 책에서도 논하지 않음.

### 실행 컨텍스트의 구성
```javascript
// =============================== (1)

var a = 1; // 전역 변수 a에 1을 할당

function outer() { // ======================= (3)
  function inner() { // ===================== (2)
    console.log(a); // 1. undefined - inner 함수 내에서 a 변수가 호이스팅되었지만 값이 아직 할당되지 않았으므로 undefined 출력
    var a = 3; // inner 함수 내에서 a 변수에 3을 할당 (지역 변수)
  }
  inner(); // 2. inner 함수의 호출, (= inner 함수의 실행 컨텍스트가 열림.)
  console.log(a); // 3. 1 - outer 함수 내에서 a 변수가 선언되지 않았으므로 전역 변수 a를 참조하여 1 출력
}

outer(); // 4. outer 함수의 호출. (= outer 함수의 실행 컨텍스트가 열림.)
console.log(a); // 5. 1 - 전역 변수 a를 참조하여 1 출력

// 결과값: undefined -> 1 -> 1 순 출력
```

### 실행컨텍스트의 추가와 삭제
<img width="452" src="https://github.com/user-attachments/assets/9cecdf16-36ae-4c07-80e2-2e0943a82d80">

1. 초기 상태: 콜 스택은 비어있음.
2. 전역 컨텍스트 생성: 자바스크립트 코드가 실행되면 전역 컨텍스트가 콜 스택에 쌓임.
3. `outer` 함수 호출: `outer` 함수가 호출되면서 `outer` 함수의 실행 컨텍스트가 콜 스택에 쌓임.
4. `inner` 함수 호출: `inner` 함수가 호출되면서 `inner` 함수의 실행 컨텍스트가 콜 스택의 최상단에 쌓임.
5. `inner` 함수 종료: `inner` 함수의 실행이 종료되면 `inner` 함수의 실행 컨텍스트가 콜 스택에서 제거됨.
6. `outer` 함수 종료: `outer` 함수의 실행이 종료되면 `outer` 함수의 실행 컨텍스트가 콜 스택에서 제거됨.
7. 전역 컨텍스트 종료: 모든 코드의 실행이 끝나면 전역 컨텍스트가 콜 스택에서 제거됨.

### 번외 : 조건문과 반복문에서 실행 컨텍스트
- ES6에서 block scope라는 개념이 추가되면서 `let`과 `const`에 대해서 별개의 독립된 공간으로서의 역할을 하고는 있지만, 별개의 실행 컨텍스트를 생성하지 않음.
- 자바스크립트는 오직 함수에 의해서만 컨텍스트를 구분할 수 있음.

### 실행 컨텍스트의 내부: 실행 컨텍스트에 포함되는 환경정보
<img width="410" src="https://github.com/user-attachments/assets/b7d18ad8-704e-4fd6-a18f-936699a266d1">

- **VariableEnvironment**: 실행 컨텍스트가 생성될 때 초기화된 식별자 정보(변수, 함수 선언 등)를 저장하는 환경임. <br>
초기화 시점 이후에는 LexicalEnvironment와 동일하게 동작함.<br> 초기 변수 상태를 저장하지만, 초기화 이후에는 변수의 값들이 변경되어도 실시간으로 반영되지 않음.
    - **Environment Record**: 현재 실행 중인 코드 블록의 식별자(변수, 함수 등) 정보를 순서대로 저장함.
    - **Outer Environment Reference**: 외부 환경을 참조하여 `스코프 체인`을 구성함.

- **LexicalEnvironment**: 실행 컨텍스트를 구성하는 환경 정보들을 모아 사전처럼 구성한 객체임. 변수와 함수의 식별자를 추적하고, 실행 중에 변수 값의 변화를 `실시간`으로 반영함.
    - **Environment Record**: 현재 실행 중인 코드 블록의 식별자(변수, 함수 등) 정보를 순서대로 저장함.
    - **Outer Environment Reference**: 외부 환경을 참조하여 `스코프 체인`을 구성함.

### 그 외

- **ThisBinding**: 
    - 함수 호출 방식에 따라 this 값이 결정됨.
    - 전역 컨텍스트에서는 전역 객체를 참조함.
    - 함수를 호출하는 방법에 따라 this에 저장되는 대상이 다름.
    - 다음 장에서 더 자세히 다룰 것.

## 호이스팅(Hoisting)과 렉시컬환경(LexicalEnvironment)
### 호이스팅(Hoisting)
- 변수와 함수 선언이 코드 상단으로 끌어올려진 것처럼 동작함.
- 렉시컬 환경은 호이스팅 메커니즘을 지원하여 코드가 실행되기 전에 변수와 함수 선언을 미리 수집함.
    - 함수 선언문은 함수명 자체가 호이스팅되지만, 함수 표현식은 변수명만 호이스팅되고 함수 내용은 호이스팅되지 않음.

### 렉시컬환경(LexicalEnvironment)
- 식별자 정보를 저장하는 어휘적 환경.
- 변수와 함수의 유효 범위를 결정함.

```javascript
// 함수 선언문
// 함수 선언문
console.log(Admin()); // 함수 선언 전에 호출해도 정상 실행

function Admin() {
    return "안녕 나는 윤아1!";
}

// (1)
try {
    console.log(Admin2());
} catch (e) {
    console.error(e); // 결과값: 에러
}

// (2)
let Admin2 = function() {
    return "안녕 나는 윤아2!";
};

console.log(Admin2()); // 결과값: 안녕 나는 윤아2!

 ```
### 변수 호이스팅
```javascript
function a() {
  console.log(x); // 초기 결과값: undefined - 변수 x는 호이스팅되었지만 값이 할당되지 않음. 따라서 undefined 출력.
  var x = 3; // 변수 x에 3을 할당함.
  console.log(x); // 결과값: 3 - 이제 x에 값 3이 할당되었기 때문에 3 출력.
}
a(); // 함수 a를 호출
```

## 스코프 (Scope)와 스코프 체인 (Scope Chain)

### 스코프
변수의 유효 범위.<br>
어떤 경계 a의 외부에서 선언한 변수는 a의 외부뿐 아니라 a의 내부에서도 접근이 가능하지만 a의 내부에서 선언한 변수는 오직 a의 내부에서만 접근할 수 있다.
```javascript
let a = "외부에서 선언한 변수"
console.log(a) // 결과 값 : 외부에서 선언한 변수
console.log(b) // 결과 값 : 에러

function inner {
    let b = "내부에서 선언한 변수"
    console.log(a) // 결과 값 : 외부에서 선언한 변수
    console.log(b) // 결과 값 : 내부에서 선언한 변수
}
```
#### 스코프의 유형
- **함수스코프** : `var`키워드로 선언. 오직 함수에 의해서만 스코프가 생성됨.(ES5까지는 let, const가 도입되지 않아 이것만 존재했음.)
```javascript
function ive() {
    var shout = 1; // 함수 스코프 생성

    while (shout <= 5) {
        console.log("귀여운걸 보면 기억을 잃는다던데");
        shout++;
    }
}

ive(); 
```

- **블록스코프** : 블록스코프: let과 const 키워드로 선언. 블록({}) 단위로 스코프가 생성됨.
```javascript
function newjeans() { // 블록 스코프 생성
    let shout = 1;

    while (shout <= 5) {
        console.log("귀여운걸 보면 기억을 잃는다던데");
        shout++;
    }
}

newjeans();
```

 ####  스코프의 구성
- **LexicalEnvironment**: 현재 실행 중인 코드 블록의 식별자(변수, 함수 등) 정보를 추적하고, 변수의 변화를 실시간으로 반영함.
- **OuterEnvironmentReference**: 현재 실행 중인 함수 또는 코드 블록의 외부 환경을 참조하여 스코프 체인을 구성함.

### 스코프 체인
스코프가 계층적으로 연결된 구조

- 함수 내부에 함수를 선언하면, 내부 함수는 외부 함수의 스코프에 접근할 수 있음.
- 내부 함수는 자신의 스코프에서 식별자를 찾지 못하면, 외부 함수의 스코프를 차례로 탐색하여 식별자를 찾음.
- 이러한 스코프 체인을 통해 자바스크립트는 변수의 유효 범위를 결정하고, 변수 은닉화를 지원함.
- `여러 스코프가 동시에 선언 되었을 때, 스코프 체인 상에서 가장 먼저 발견된 식별자에게만 접근가능.`
```javascript
let yoonahAge1 = 20; // 전역 변수 선언

function outerFunction() {
    let yoonahAge2 = 24;

    function printAge() {
        let yoonahAge3 = 22;
        console.log("희망나이 : ", yoonahAge1); // 결과값: 20 - 전역 변수 yoonahAge1 참조
        console.log("진짜나이 : ", yoonahAge2); // 결과값: 24 - outerFunction 스코프 변수 yoonahAge2 참조
        console.log("법정나이 : ", yoonahAge3); // 결과값: 22 - printAge 스코프 변수 yoonahAge3 참조
    }

    printAge();
}

outerFunction();
```

### 과정을 사진으로 정리한 것
<img width="465" src="https://github.com/user-attachments/assets/20a85272-16b4-4710-98a6-b810cdfdb19b">