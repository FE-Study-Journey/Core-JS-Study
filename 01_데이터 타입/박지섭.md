# 1장 데이터 타입

## 1-1 데이터 타입의 종류

- 자바스크립트의 데이터 타입은 `기본형`과 `참조형`으로 나뉜다.
- 기본형 : `number`, `String`, `boolean`, `null`, `undefined`, `Symbol(ES6)`
- 참조형 : `Object`, `Array`, `Function`, `Date`, `RegExp`
  - 참조형(ES6) : `Map`, `WeakMap`, `Set`, `WeakSet`

- 기본형은 `불변성(immutability)`를 가집니다.
   - 혹시 이승진 교수님 immutable 챕터 있으신분..? 찾으려고 보니까 안보이네용..


### 참고하면 좋은 래퍼런스
- <a href="https://poiemaweb.com/es6-symbol">Symbol 이란? </a>
  - 사실 아직 써보질 않아서 잘 모르겠어요 써보신분..?

- <a href="https://inpa.tistory.com/entry/JS-%F0%9F%9A%80-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%B5%9C%EC%8B%A0-%EB%AC%B8%EB%B2%95-%EC%A0%95%EB%A6%AC-ES6-ES12">ECMASript 2015(ES6) </a>
  - ES6문법인줄 모르고 사용하던 문법이 많으니까 보면 좋을 듯합니다.

## 1-2 데이터 타입에 관한 배경지식

``` javascript
1byte = 8bit
2byte = 16bit = 2**16 = 65536개의 값
```
- C/C++, Java 등의 정적 타입 언어는 데이터 타입별 메모리 영역을 2바이트, 4바이트 등으로 나눠서 정해뒀음.
  - short(2byte)는 0을 포함해 -32,768 ~ +32,767의 숫자만 가능
  - int(4byte)는 0을 포함한 -2,147,483,648 ~ +2,147,473,647의 숫자만 가능
>알쓸신잡 : <br/> 
메이플 스토리등을 포함한 여러 게임들의 예전 재화의 최대량이 2,147,473,647이였다. <br/> 왜? int형으로 지정해놨기 때문

- 자바스크립트는 메모리 영역을 8바이트를 할당했습니다.
- `비트(bit)`는 고유한 식별자를 지닌다. `바이트` 역시 `비트의 식별자`로 위치를 파악한다.
- 모든 데이터는 바이트 단위의 `식별자` 정확한 표현으로는 `메모리 주솟값`을 통해 서로를 구분하고 연결한다.

### 식별자 vs 변수
- 변수 : `변할 수 있는 수`
- 식별자: 어떤 데이터를 식별하는 데 사용하는 이름, 즉 `변수명`

## 1-3 변수 선언과 데이터 할당

- var, let, const의 동작 원리 차이
  - **var**
    - 함수 스코프를 가집니다.
    - 같은 변수를 다시 선언할 수 있습니다.
    - 선언 이전에도 접근이 가능하지만, `undefined`입니다. (호이스팅)

  - **let**
    - 블록 스코프를 가집니다.
    - 같은 블록 내에서 다시 선언할 수 없습니다.
    - 선언 이전에는 접근할 수 없습니다. (일시적 사각지대)  

  - **const**
    - 블록 스코프를 가집니다.
    - 선언과 동시에 초기화해야 합니다.
    - 재할당이 불가능합니다.
    - 객체의 경우 속성을 변경할 수 있지만, 변수 자체를 변경할 수는 없습니다.

- 변수 선언과 할당
  - 선언 과정: 비어있는 공간을 확보 후, 식별자를 지정
  - 할당 과정: 선언한 공간에 값(ex:문자열)을 할당

### 중요한 것: 다만 값(ex:문자열)을 직접 저장하는 것은 아님!

- 데이터 변환은 `자유로움` 과 동시에 메모리를 `효울적으로 관리`를 위해 만들어짐.
- 숫자같이 공간이 확보된 값이 아닌 다른 값들은 정해진 규격이 없기 때문에 `가변적`입니다.
  - `가변적`인 속성 때문에 값을 직접적으로 저장하면 수정할 때 연산이 많아 지는 단점이 있습니다.

- 문자열 값을 변경할 시 `무조건` 새로 만들어서 별도의 공간에 저장합니다.
  - 변경되어 이전의 값을 사용하지 않는다면 `가비지 컬렉션`에 의해 정리됩니다.


## 1-4 기본형 데이터와 참조형 데이터

### 불변값 vs 상수
- 구분 하는 기준은 `변경 가능성의 대상` 입니다
- 불변값 : 데이터 영역 메모리
- 상수: 변수 영역 메모리

- 위에서 예시를 든 것처럼 값을 변경하면 값이 변경되는 것이 아니라 새로 만들어서 저장되는 것 입니다.
  - 그래서 `5`를 `7`를 바꾸더라도 `5`와 `7`이 총 두개가 만들어져 있는 것입니다.
    - 데이터가 가리키는 주소만 바뀐 것
    - 한 번 만들어진 값은 가비지 컬렉팅을 당하지 않는 한 영원히 변하지 않습니다

### 가변 값
- 기본형 데이터는 모두 `불변값`이다.
  - 그렇다면 참조형 데이터는 `가변값`인가?
  > 데이터 영역에 저장되는 모든 값은 `불변값`이다.
  - 다만 변수에는 다른 값을 대입할 수 있기 때문에, 흔히 참조형 데이터는 `불변하지않다`. 라고 하는 것입니다.

- 그래서 참조형 데이터의 프로퍼티에 다시 참조형 데이터를 할당하는 경우를 `중첩 객체` 라고 함

### 변수 복사(기본형 데이터 vs 참조형 데이터)

- 엄밀히 따지면 자바스크립트의 모든 데이터 타입은 `참조형 데이터`일 수 밖에 없다.
  - 기본형은 주솟값 복사를 1번만 하는 것이고, 참조형은 한 단계 더 하는 차이만 있을 뿐입니다.

- 참조형 데이터가 `가변값`이라고 설명할 때의 `가변`은 참조형 데이터 자체를 변경할 경우가 아니라 그 내부의 프로퍼티를 변경할`때만` 성립합니다.
- 그래서 결국은 모두 `값을 보는 것이 아닌 주소값`을 확인해야합니다. 

## 1-5 불변 객체

- 참조형 데이터의 `가변`은 데이터 자체가 아닌 내부 프로퍼티를 수정하려고 할때만 성립합니다.
- 데이터 자체를 변경하고자 하면 가본형 데이터와 마찬가지로 **기존 데이터는 변하지않습니다.**

- 불변 객체를 사용해야할 때가 언제인가?
> 값으로 전달받은 객체에 변경을 가하더라도 원본 객체는 변하지 않아야 할 때

```
일정이 너무 빠듯해서 해당 부분 예시와 이해가 안되는 부분을 작성하지 못했습니다. 해당 부분은 추후에 추가하도록 하겠습니다.
```

### 다 하신분께 질문하고 싶은 내용
1. p.23 하단에 나오는 예시를 봤을 때 차라리 `Map`을 사용하는 것이 효율이 좋지 않나? 라는 의구심이 듭니다.
2. p.24 객체의 변경을 원하지 않는다면 `Object.freeze`를 사용하는 방법도 있는데 해당 부분은 일부러 안쓴것인지? 아니면 사용하면 안되는 것인지 궁금합니다. 

### 얕은 복사 vs 깊은 복사
- 얕은 복사: 바로 아래 단계의 값만 복사하는 방법(중첩된 객체에서 참조형 데이터가 저장된 프로퍼티를 복사할 때 `주소값`만 복사)
  - 원본과 사본이 모두 동일한 참조형 데이터의 주소를 가리키게 됨. 수정시 둘다 같이 바뀜
- 깊은 복사: 중첩된 객체에서 참조형 데이터가 있을 대 마다 재귀적으로 한번 더 그 내부의 프로퍼티들을 복사
  - 이렇게 해야지 어느쪽의 프로퍼티를 변경하더라도 다른 쪽에 영향을 주지 않습니다.

> target !== null 이라는 조건을 덧붙인 이유는 typeof 명령어가 null에 대해서도 `object`를 반환하기 때문입니다.(자바스크립트 자체 버그)

## 1-6 undefined와 null
<img src="https://velog.velcdn.com/images%2F1sonjm%2Fpost%2F65f36e8a-4e6f-48ee-bf44-d154274b0dd0%2FT9M2J.png" width="80%"/> <br/>

- 위와 같은 그림처럼 예시를 들 수 있다. 둘 다 없다라는 의미는 같지만, undefined는 `정의하지 않았다` 라는 의미가 더 강합니다.

### undefined가 반환하는 경우
1. 값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때
    - ex: var
2. 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때
3. return문이 없거나 호출되지 않는 함수의 실행 결과    

- 다만 Array를 사용해서 length 프로퍼티에 값을 부여하면 빈 공간을 확보하기 때문에 해당 공백은 undefined가 아니다.
  - 아직 존재하지 않는 프로퍼티

- 이로써 null과 undefined를 헷갈리게 사용하지 않기 위해서 해야하는 방법
  - 사용자가 직접 undefined를 할당하지 말기
- null이 있는데 굳이 undefined를 사용할 이유가 없습니다. 애초에 이럴 때 사용하라고 만든게 null입니다.
  - 다만 상단에 기재한 typeof에 관한 자바스크립트 버그를 주의해야합니다.

  그래서 자바스크립트에서는 값을 비교할 때 동등연산자(==)가 아닌 일치연산자(===)를 써야지 정확하게 판별할 수 있습니다.

